---
import Layout from "../layouts/Layout.astro";
---

<Layout title="buttons galore">
  <h1>buttons galore!</h1>
  my personal collection of 88x31 buttons (that you can contribute to), all in one place!
  <a href="https://github.com/ThinLiquid/buttons">github repo</a>

  <div class="tooltip" style={{ position: 'absolute', background: 'var(--base)', zIndex: 69696969, padding: '5px', border: '2px dashed var(--surface0)', borderRadius: '5px' }}></div>

  <input type="text" id="search" placeholder="search for a button..." style={{ width: '100%' }} />

  <div style={{ display: 'flex' }}>
    <label for="categories"></label>
    <select id="categories" style={{ flex: 1 }}>
      <option>All Categories</option>
    </select>
    <label for="sort"></label>
    <select id="sort" style={{ flex: 1 }}>
      <option value="alphabetical">Alphabetical</option>
      <option value="alphabetical-reverse">Alphabetical (Reverse)</option>
      <option value="order">Order</option>
      <option value="order-reverse">Order (Reverse)</option>
      <option value="random">Random</option>
    </select>
    <label for="creators"></label>
    <select id="creators" style={{ flex: 1 }}>
      <option>All Creators</option>
    </select>
  </div>

  <div class="buttons"></div>
</Layout>

<script>
  const BUTTON_FILE = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/index.buttonfile';
  const BUTTON_DIRECTORY = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/img/';
  let activeRender = null;

  const fetchButtons = async () => {
    const res = await fetch(`${BUTTON_FILE}`, { cache: 'no-store' });
    const data = await res.text();
    const entries = data.split('\n').map((entry, index) => {
      const [categories, tags, filename, description, creator] = entry.split(' | ');
      try {
        return { categories: (categories as any).split(','), tags: (tags as string).split(' '), filename, description, creator: creator || 'N/A' };
      } catch {
        console.error('Error: malformed content\n ->', JSON.stringify(entry), 'at line', index);
        return null;
      }
    }).filter(entry => entry !== null);

    return entries;
  };

  const debounce = (func, delay = 300) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), delay);
    };
  };

  const renderButtons = async () => {
    if (activeRender) activeRender.abort();
    const controller = new AbortController();
    activeRender = controller;
    
    const buttonsContainer = document.querySelector('.buttons');
    buttonsContainer.innerHTML = '';
    const fragment = document.createDocumentFragment();

    const filteredButtons = buttons.filter(button => {
      const category = categoriesSelect.value;
      const creator = creatorsSelect.value;
      const searchValue = search.value.toLowerCase();

      return (
        (category === 'All Categories' || button.categories.includes(category)) &&
        (creator === 'All Creators' || button.creator === creator) &&
        ((button.description as string).toLowerCase().includes(searchValue) || button.tags.some(tag => tag.includes(searchValue)))
      );
    });

    filteredButtons.slice(0, 50).forEach(button => {  // Limit initial render to 50 items
      const buttonElement = document.createElement('img');
      buttonElement.src = `${BUTTON_DIRECTORY}${button.filename}`;
      buttonElement.alt = button.description!;
      buttonElement.width = 88;
      buttonElement.height = 31;
      buttonElement.loading = 'lazy';
      buttonElement.classList.add('squishy');

      buttonElement.addEventListener('mouseover', () => {
        tooltip.innerHTML = `
          <strong>${button.description}</strong><br />
          Categories: ${button.categories.join(', ')}<br />
          Tags: ${button.tags.join(', ')}<br />
          Creator: ${button.creator}
        `;
        tooltip.style.opacity = '1';
      });

      buttonElement.addEventListener('mouseout', () => {
        tooltip.style.opacity = '0';
      });

      fragment.appendChild(buttonElement);
    });

    buttonsContainer.appendChild(fragment);
    activeRender = null;
  };

  (async () => {
    const buttons = await fetchButtons();
    const categories = [...new Set(buttons.flatMap(button => button.categories))];
    const creators = [...new Set(buttons.map(button => button.creator))];

    const buttonsContainer = document.querySelector('.buttons');
    const search = document.getElementById('search');
    const categoriesSelect = document.getElementById('categories');
    const sortSelect = document.getElementById('sort');
    const creatorsSelect = document.getElementById('creators');
    const tooltip = document.querySelector('.tooltip');

    categories.forEach(category => {
      const option = document.createElement('option');
      option.innerText = category;
      categoriesSelect.appendChild(option);
    });

    creators.forEach(creator => {
      const option = document.createElement('option');
      option.innerText = creator;
      creatorsSelect.appendChild(option);
    });

    const debouncedRenderButtons = debounce(renderButtons);
    search.addEventListener('input', debouncedRenderButtons);
    categoriesSelect.addEventListener('change', renderButtons);
    creatorsSelect.addEventListener('change', renderButtons);
    sortSelect.addEventListener('change', renderButtons);

    renderButtons();
  })();

  window.addEventListener('mousemove', (e) => {
    const tooltip = document.querySelector('.tooltip');
    tooltip.style.left = `${e.clientX + 10}px`;
    tooltip.style.top = `${e.clientY + 10}px`
<style>
  .buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0px;
    margin-top: 10px;
    justify-content: center;

    img {
      transition: scale .2s var(--bounce), rotate .2s var(--bounce);
      &:hover {
        z-index: 6969;
        scale: 1.5;

        &:nth-child(even) {
          rotate: 2deg;
        }

        &:nth-child(odd) {
          rotate: -2deg;
        }
      }
    }
  }
</style>
<style is:global>
  content .tooltip {
    visibility: hidden;
  }

  content:hover .tooltip {
    visibility: visible;
  }

  body, html {
    overflow-x: hidden;
  }
</style>
