---
import Layout from "../layouts/Layout.astro";
---

<Layout title="buttons galore">
  <h1>buttons galore!</h1>
  my personal collection of 88x31 buttons (that you can contribute to), all in one place!
  <a href="https://github.com/ThinLiquid/buttons">github repo</a>

  <div class="tooltip" style={{ position: 'absolute', background: 'var(--base)', zIndex: 69696969, padding: '5px', border: '2px dashed var(--surface0)', borderRadius: '5px' }}></div>

  <input type="text" id="search" placeholder="search for a button..." style={{ width: '100%' }} />

  <div style={{ display: 'flex' }}>
    <label for="categories"></label>
    <select id="categories" style={{ flex: 1 }}>
      <option>All Categories</option>
    </select>
    <label for="sort"></label>
    <select id="sort" style={{ flex: 1 }}>
      <option value="alphabetical">Alphabetical</option>
      <option value="alphabetical-reverse">Alphabetical (Reverse)</option>
      <option value="order">Order</option>
      <option value="order-reverse">Order (Reverse)</option>
      <option value="random">Random</option>
    </select>
    <label for="creators"></label>
    <select id="creators" style={{ flex: 1 }}>
      <option>All Creators</option>
    </select>
  </div>

  <div class="buttons"></div>
</Layout>

<script>
  const BUTTON_FILE = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/index.buttonfile';
  const BUTTON_DIRECTORY = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/img/';

  const fetchButtons = async () => {
    const res = await fetch(BUTTON_FILE, { cache: 'no-store' });
    const data = await res.text();
    const entries = data.split('\n').map((entry, index) => {
      const [categories, tags, filename, description, creator] = entry.split(' | ');
      try {
        return {
          categories: categories.split(','),
          tags: tags.split(' '),
          filename,
          description,
          creator: creator || 'N/A'
        };
      } catch {
        console.error('Error: malformed content\n ->', JSON.stringify(entry), 'at line', index);
        return null;
      }
    }).filter(entry => entry !== null);
    return entries as any[];
  };

  const debounce = (func: Function, delay = 300) => {
    let timeout: ReturnType<typeof setTimeout>;
    return (...args: any[]) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), delay);
    };
  };

  (async () => {
    const buttons = await fetchButtons();
    const categories = [...new Set(buttons.flatMap(button => button.categories))];
    const creators = [...new Set(buttons.map(button => button.creator))];

    const buttonsContainer = document.querySelector('.buttons') as HTMLDivElement | null;
    const search = document.getElementById('search') as HTMLInputElement | null;
    const categoriesSelect = document.getElementById('categories') as HTMLSelectElement | null;
    const sortSelect = document.getElementById('sort') as HTMLSelectElement | null;
    const creatorsSelect = document.getElementById('creators') as HTMLSelectElement | null;
    const tooltip = document.querySelector('.tooltip') as HTMLDivElement | null;

    if (!buttonsContainer || !search || !categoriesSelect || !sortSelect || !creatorsSelect || !tooltip) {
      console.error("One or more elements could not be found.");
      return;
    }

    categories.forEach(category => {
      const option = document.createElement('option');
      option.innerText = category;
      categoriesSelect.appendChild(option);
    });

    creators.forEach(creator => {
      const option = document.createElement('option');
      option.innerText = creator;
      creatorsSelect.appendChild(option);
    });

    let activeRender: AbortController | null = null;

    const renderButtons = async () => {
      buttonsContainer.innerHTML = '';

      if (activeRender) activeRender.abort();
      activeRender = new AbortController();

      const filteredButtons = buttons.filter(button => {
        const category = categoriesSelect?.value || 'All Categories';
        const creator = creatorsSelect?.value || 'All Creators';
        const searchValue = search?.value.toLowerCase() || '';

        return (
          (category === 'All Categories' || button.categories.includes(category)) &&
          (creator === 'All Creators' || button.creator === creator) &&
          (button.description.toLowerCase().includes(searchValue) ||
           button.tags.some(tag => tag.includes(searchValue)))
        );
      });

      const sortOption = sortSelect?.value;
      if (sortOption === 'alphabetical') {
        filteredButtons.sort((a, b) => a.description.localeCompare(b.description));
      } else if (sortOption === 'alphabetical-reverse') {
        filteredButtons.sort((a, b) => b.description.localeCompare(a.description));
      } else if (sortOption === 'order-reverse') {
        filteredButtons.reverse();
      } else if (sortOption === 'random') {
        filteredButtons.sort(() => Math.random() - 0.5);
      }

      const fragment = document.createDocumentFragment();
      for (const button of filteredButtons.slice(0, 50)) { // Limit to 50 items
        const buttonElement = document.createElement('img');
        buttonElement.src = `${BUTTON_DIRECTORY}${button.filename}`;
        buttonElement.alt = button.description;
        buttonElement.width = 88;
        buttonElement.height = 31;

        buttonElement.addEventListener('mouseover', () => {
          tooltip.innerHTML = `
            <strong>${button.description}</strong><br />
            Categories: ${button.categories.join(', ')}<br />
            Tags: ${button.tags.join(', ')}<br />
            Creator: ${button.creator}
          `;
          tooltip.style.opacity = '1';
        });

        buttonElement.addEventListener('mouseout', () => {
          tooltip.style.opacity = '0';
        });

        fragment.appendChild(buttonElement);
      }
      buttonsContainer.appendChild(fragment);
    };

    const debouncedRenderButtons = debounce(renderButtons, 300);

    search.addEventListener('input', debouncedRenderButtons);
    categoriesSelect.addEventListener('change', renderButtons);
    creatorsSelect.addEventListener('change', renderButtons);
    sortSelect.addEventListener('change', renderButtons);
  })();

  window.addEventListener('mousemove', (e) => {
    const tooltip = document.querySelector('.tooltip') as HTMLDivElement | null;
    if (tooltip) {
      tooltip.style.left = `${e.clientX + 10}px`;
      tooltip.style.top = `${e.clientY + 10}px`;
    }
  });
</script>
<style>
  .buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0px;
    margin-top: 10px;
    justify-content: center;

    img {
      transition: scale .2s var(--bounce), rotate .2s var(--bounce);
      &:hover {
        z-index: 6969;
        scale: 1.5;

        &:nth-child(even) {
          rotate: 2deg;
        }

        &:nth-child(odd) {
          rotate: -2deg;
        }
      }
    }
  }
</style>
<style is:global>
  content .tooltip {
    visibility: hidden;
  }

  content:hover .tooltip {
    visibility: visible;
  }

  body, html {
    overflow-x: hidden;
  }
</style>
