---
import Layout from "../layouts/Layout.astro";
---

<Layout title="buttons galore">
  <h1>buttons galore!</h1>
  my personal collection of 88x31 buttons (that you can contribute to), all in one place!
  <a href="https://github.com/ThinLiquid/buttons">github repo</a>

  <div class="tooltip" style={{ position: 'absolute', background: 'var(--base)', zIndex: 69696969, padding: '5px', border: '2px dashed var(--surface0)', borderRadius: '5px' }}></div>

  <input type="text" id="search" placeholder="search for a button..." style={{ width: '100%' }} />

  <div style={{ display: 'flex' }}>
    <label for="categories"></label>
    <select id="categories" style={{ flex: 1 }}>
      <option>All Categories</option>
    </select>
    <label for="sort"></label>
    <select id="sort" style={{ flex: 1 }}>
      <option value="alphabetical">Alphabetical</option>
      <option value="alphabetical-reverse">Alphabetical (Reverse)</option>
      <option value="order">Order</option>
      <option value="order-reverse">Order (Reverse)</option>
      <option value="random">Random</option>
    </select>
    <label for="creators"></label>
    <select id="creators" style={{ flex: 1 }}>
      <option>All Creators</option>
    </select>
  </div>

  <div class="buttons"></div>
</Layout>

<script>
  const BUTTON_FILE = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/index.buttonfile';
  const BUTTON_DIRECTORY = 'https://raw.githubusercontent.com/ThinLiquid/buttons/main/img/';

  const fetchButtons = async () => {
    const res = await fetch(BUTTON_FILE, { cache: 'no-store' });
    const data = await res.text();
    return data.split('\n').map((entry, index) => {
      const [categories = '', tags = '', filename, description, creator] = entry.split(' | ');
      try {
        return {
          categories: categories ? categories.split(',') : [],
          tags: tags ? tags.split(' ') : [],
          filename,
          description,
          creator: creator || 'N/A'
        };
      } catch {
        console.error('Error: malformed content\n ->', JSON.stringify(entry), 'at line', index);
        return null;
      }
    }).filter(entry => entry !== null) as any[];
  };

  (async () => {
    const buttons = await fetchButtons();
    const categories = [...new Set(buttons.flatMap(button => button.categories))];
    const creators = [...new Set(buttons.map(button => button.creator))];

    const buttonsContainer = document.querySelector('.buttons') as HTMLDivElement | null;
    const search = document.getElementById('search') as HTMLInputElement | null;
    const categoriesSelect = document.getElementById('categories') as HTMLSelectElement | null;
    const sortSelect = document.getElementById('sort') as HTMLSelectElement | null;
    const creatorsSelect = document.getElementById('creators') as HTMLSelectElement | null;
    const tooltip = document.querySelector('.tooltip') as HTMLDivElement | null;

    if (!buttonsContainer || !search || !categoriesSelect || !sortSelect || !creatorsSelect || !tooltip) {
      console.error("One or more elements could not be found.");
      return;
    }

    categories.forEach(category => {
      const option = document.createElement('option');
      option.innerText = category;
      categoriesSelect.appendChild(option);
    });

    creators.forEach(creator => {
      const option = document.createElement('option');
      option.innerText = creator;
      creatorsSelect.appendChild(option);
    });

    buttons.forEach(button => {
      const buttonElement = document.createElement('img');
      buttonElement.src = `${BUTTON_DIRECTORY}${button.filename}`;
      buttonElement.alt = button.description;
      buttonElement.width = 88;
      buttonElement.height = 31;
      buttonElement.classList.add('button-item');

      buttonElement.dataset.categories = button.categories.join(',');
      buttonElement.dataset.tags = button.tags.join(',');
      buttonElement.dataset.creator = button.creator;
      buttonElement.dataset.description = button.description.toLowerCase();

      buttonElement.addEventListener('mouseover', () => {
        tooltip.innerHTML = `
          <strong>${button.description}</strong><br />
          Categories: ${button.categories.join(', ')}<br />
          Tags: ${button.tags.join(', ')}<br />
          Creator: ${button.creator}
        `;
        tooltip.style.opacity = '1';
      });

      buttonElement.addEventListener('mouseout', () => {
        tooltip.style.opacity = '0';
      });

      buttonsContainer.appendChild(buttonElement);
    });

    const filterAndSortButtons = () => {
      const category = categoriesSelect?.value || 'All Categories';
      const creator = creatorsSelect?.value || 'All Creators';
      const searchValue = search?.value.toLowerCase() || '';

      const buttonElements = buttonsContainer?.querySelectorAll('.button-item') as NodeListOf<HTMLImageElement>;

      buttonElements.forEach(button => {
        const matchesCategory = category === 'All Categories' || button.dataset.categories?.includes(category);
        const matchesCreator = creator === 'All Creators' || button.dataset.creator === creator;
        const matchesSearch =
          button.dataset.description?.includes(searchValue) ||
          button.dataset.tags?.includes(searchValue);

        if (matchesCategory && matchesCreator && matchesSearch) {
          button.classList.remove('hidden');
        } else {
          button.classList.add('hidden');
        }
      });

      const sortOption = sortSelect?.value;
      const sortedButtons = Array.from(buttonElements)
        .filter(button => !button.classList.contains('hidden'));

      if (sortOption === 'alphabetical') {
        sortedButtons.sort((a, b) => a.dataset.description!.localeCompare(b.dataset.description!));
      } else if (sortOption === 'alphabetical-reverse') {
        sortedButtons.sort((a, b) => b.dataset.description!.localeCompare(a.dataset.description!));
      } else if (sortOption === 'order-reverse') {
        sortedButtons.reverse();
      } else if (sortOption === 'random') {
        sortedButtons.sort(() => Math.random() - 0.5);
      }

      sortedButtons.forEach(button => buttonsContainer!.appendChild(button));
    };

    search?.addEventListener('input', filterAndSortButtons);
    categoriesSelect?.addEventListener('change', filterAndSortButtons);
    creatorsSelect?.addEventListener('change', filterAndSortButtons);
    sortSelect?.addEventListener('change', filterAndSortButtons);
  })();

  window.addEventListener('mousemove', (e) => {
    const tooltip = document.querySelector('.tooltip') as HTMLDivElement | null;
    if (tooltip) {
      tooltip.style.left = `${e.clientX + 10}px`;
      tooltip.style.top = `${e.clientY + 10}px`;
    }
  });
</script>
<style>
  .hidden {
    display: none;
  }
</style>
<style>
  .buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0px;
    margin-top: 10px;
    justify-content: center;

    img {
      transition: scale .2s var(--bounce), rotate .2s var(--bounce);
      &:hover {
        z-index: 6969;
        scale: 1.5;

        &:nth-child(even) {
          rotate: 2deg;
        }

        &:nth-child(odd) {
          rotate: -2deg;
        }
      }
    }
  }
</style>
<style is:global>
  content .tooltip {
    visibility: hidden;
  }

  content:hover .tooltip {
    visibility: visible;
  }

  body, html {
    overflow-x: hidden;
  }
</style>
